
-- Sylvio Corrêa e Annderson Oreto

n = 3

Procs = {0..n-1}

channel req, sc: Procs

channel resp: Procs.Procs
        

P_idle(i) = []x:Procs @ req.x ->
    if x==i
    then P_wantSC(i,n-1,<>)
    else P_idle(i) ||| P_resp(i,x) -- paralelismo não alfabetizado, mais conhecido como interleaving [|{}|]

P_resp(i,x) = resp.i.x -> SKIP

P_wantSC(i, count, wt) = if count==0
                         then P_inSC(i,wt)
                         else []x : diff(Procs, {i})@ (
                               req.x -> P_wantSC(i, count, <x>^wt)
                               []
                               resp.x.i -> P_wantSC(i, (count-1), wt)
                               )
                

P_inSC(i,wt) = sc.i -> P_leaveSC(i, wt)
               []
               []x:diff(Procs, {i}) @ req.x -> P_inSC(i, <x>^wt)
               --Escolha entre req.1, req.2, ...

P_leaveSC(i, wt) = if (wt == <>)
                   then P_idle(i)
                   else resp.i.head(wt) -> P_leaveSC(i, tail(wt))

Alpha(i) =
    {req.k, sc.i, resp.i.j, resp.j.i | j:diff(Procs, {i}), k:Procs}
    
System = || i:Procs @ [Alpha(i)] P_idle(i)
